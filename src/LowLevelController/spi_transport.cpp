// Copyright Â© Svetoslav Paregov. All rights reserved.

#include <stdio.h>          // Standard input/output for printf
#include "pico/stdlib.h"    // Pico SDK standard library (for stdio_init_all, sleep_ms)
#include "hardware/spi.h"   // Hardware SPI functions
#include "hardware/gpio.h"  // Hardware GPIO functions (for gpio_set_function)
#include "pico/binary_info.h" // For picotool information
#include "spi_transport.hpp"
#include "common_types.hpp" // For common types like motor_commant_t
#include "cyclic_buffer.hpp" // For CyclicBuffer class

// SPI Configuration Defines
// We will use SPI0 peripheral on the Raspberry Pi Pico W.
#define SPI_PORT spi0       // Specify SPI0 as the peripheral instance
#define SPI_IRQ  SPI0_IRQ // The interrupt request number for SPI0

// GPIO pins for SPI0. These are the default pins for SPI0 on the Pico.
// Ensure your master device is connected to these pins.
#define PIN_MISO 19          // GP16: Master In, Slave Out (Data from slave to master)
#define PIN_CS   17          // GP17: Chip Select (Active low, asserted by master to select slave)
#define PIN_SCK  18          // GP18: Serial Clock (Generated by master)
#define PIN_MOSI 16          // GP19: Master Out, Slave In (Data from master to slave)

#define LED_PIN PICO_DEFAULT_LED_PIN

#define SPI_SYNC_BYTE 0xAF
#define SPI_SYNC_BYTES_COUNT 4 // Number of sync bytes to expect at the start of a message

#define COMMANDS_BUFFER_SIZE 64

// Protocol and Buffer Configuration
#define MAX_BUFFER_SIZE 512
#define LENGTH_SIZE 4

uint8_t debug_buffer[1024];
uint32_t debug_buffer_index = 0;

// Double buffers for receiving data
uint8_t buffer_a[MAX_BUFFER_SIZE];
uint8_t buffer_b[MAX_BUFFER_SIZE];
// Buffer to hold the length of the message
uint8_t length_buffer[LENGTH_SIZE];

// Volatile pointers and flags to manage buffers and state between main loop and ISRs (if used)
// `active_buffer` is where the SPI hardware is currently writing data.
volatile uint8_t *active_buffer = buffer_a;
// `processing_buffer` points to the buffer that is full and ready for the main loop to use.
volatile uint8_t *processing_buffer = NULL;
volatile uint32_t message_length = 8;
volatile uint32_t received_count = 0;
volatile uint32_t length_received_count = 0;
volatile uint8_t sync_bytes_received = 0;

volatile uint8_t spi_return_byte = 0x00;

CyclicBuffer<command_8_bytes_t, COMMANDS_BUFFER_SIZE> commands_buffer;

void spi_irq_handler();

void init_spi()
{
    // Initialize the SPI peripheral.
    spi_init(SPI_PORT, 500 * 1000);

    // Configure the SPI peripheral to operate in slave mode.
    // This is crucial for the Pico to act as a receiver.
    spi_set_slave(SPI_PORT, true);

    // Set up the GPIO pins for their SPI functions.
    // These functions map the physical pins to the SPI peripheral's signals.
    gpio_set_function(PIN_MISO, GPIO_FUNC_SPI); // MISO as SPI function
    gpio_set_function(PIN_CS,   GPIO_FUNC_SPI); // CS as SPI function
    gpio_set_function(PIN_SCK,  GPIO_FUNC_SPI); // SCK as SPI function
    gpio_set_function(PIN_MOSI, GPIO_FUNC_SPI); // MOSI as SPI function

    // Enable the SPI interrupt (specifically for receive FIFO not empty)
    // The '1' enables the RX FIFO interrupt. The other '0's disable other sources.
    spi_get_hw(SPI_PORT)->imsc = (1 << SPI_SSPIMSC_RXIM_LSB);

    // Set the handler function for the SPI IRQ
    irq_set_exclusive_handler(SPI_IRQ, spi_irq_handler);
    
    // Enable the IRQ in the Nested Vector Interrupt Controller (NVIC)
    irq_set_enabled(SPI_IRQ, true);
    
    hw_set_bits(&spi_get_hw(SPI_PORT)->imsc, SPI_SSPIMSC_RXIM_BITS);
}

// This function is called automatically whenever the SPI peripheral has data.
void spi_irq_handler()
{
    // As long as data is in the receive FIFO, process it.
    while (spi_is_readable(SPI_PORT))
    {
        uint8_t received_byte;
        spi_read_blocking(SPI_PORT, spi_return_byte, &received_byte, 1);

        if (received_count < MAX_BUFFER_SIZE)
        {
            active_buffer[received_count++] = received_byte;
        }

        if (received_count >= message_length)
        {
            // Message complete. Make it available for the main loop.
            processing_buffer = active_buffer;
            received_count = 0;

            // Switch to the other buffer for the next reception.
            active_buffer = (active_buffer == buffer_a) ? buffer_b : buffer_a;

            command_8_bytes_t command;
            command.type = (command_type_t)processing_buffer[0]; // The first byte is the command type
            command.data[0] = processing_buffer[1];
            command.data[1] = processing_buffer[2];
            command.data[2] = processing_buffer[3];
            command.data[3] = processing_buffer[4];
            command.data[4] = processing_buffer[5];
            command.data[5] = processing_buffer[6];
            command.data[6] = processing_buffer[7];

            commands_buffer.push(command);
        }
    }
}

command_8_bytes_t spi_get_received_command()
{
    command_8_bytes_t command;
    if (commands_buffer.pop(command))
    {
        return command;
    }
    else
    {
        // If no command is available, return an invalid command
        command.type = INVALID_COMMAND;
        return command;
    }
}

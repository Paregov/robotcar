// Copyright Â© Svetoslav Paregov. All rights reserved.

#include <stdio.h>          // Standard input/output for printf
#include "pico/stdlib.h"    // Pico SDK standard library (for stdio_init_all, sleep_ms)
#include "hardware/spi.h"   // Hardware SPI functions
#include "hardware/gpio.h"  // Hardware GPIO functions (for gpio_set_function)
#include "pico/binary_info.h" // For picotool information
#include "spi_transport.hpp"

// --- SPI Configuration Defines ---
// We will use SPI0 peripheral on the Raspberry Pi Pico W.
#define SPI_PORT spi0       // Specify SPI0 as the peripheral instance
#define SPI_IRQ  SPI0_IRQ // The interrupt request number for SPI0

// GPIO pins for SPI0. These are the default pins for SPI0 on the Pico.
// Ensure your master device is connected to these pins.
#define PIN_MISO 19          // GP16: Master In, Slave Out (Data from slave to master)
#define PIN_CS   17          // GP17: Chip Select (Active low, asserted by master to select slave)
#define PIN_SCK  18          // GP18: Serial Clock (Generated by master)
#define PIN_MOSI 16          // GP19: Master Out, Slave In (Data from master to slave)

#define LED_PIN PICO_DEFAULT_LED_PIN

#define SPI_SYNC_BYTE 0xAF
#define SPI_SYNC_BYTES_COUNT 4 // Number of sync bytes to expect at the start of a message

// --- Protocol and Buffer Configuration ---
#define MAX_BUFFER_SIZE 512
#define LENGTH_SIZE 4
const uint8_t ACK_SUCCESS = 0x06; // Standard ASCII Acknowledge
const uint8_t NAK_FAILURE = 0x15; // Standard ASCII Negative Acknowledge

uint8_t debug_buffer[1024];
uint32_t debug_buffer_index = 0;

// Double buffers for receiving data
uint8_t buffer_a[MAX_BUFFER_SIZE];
uint8_t buffer_b[MAX_BUFFER_SIZE];
// Buffer to hold the length of the message
uint8_t length_buffer[LENGTH_SIZE];

// Volatile pointers and flags to manage buffers and state between main loop and ISRs (if used)
// `active_buffer` is where the SPI hardware is currently writing data.
volatile uint8_t *active_buffer = buffer_a;
// `processing_buffer` points to the buffer that is full and ready for the main loop to use.
volatile uint8_t *processing_buffer = NULL;
volatile uint32_t message_length = 0;
volatile uint32_t received_count = 0;
volatile uint32_t length_received_count = 0;
volatile uint8_t sync_bytes_received = 0;

volatile uint8_t spi_return_byte = 0x00;

// State machine for the SPI communication protocol
typedef enum {
    STATE_WAIT_FOR_LEN,
    STATE_RECEIVING_DATA,
    STATE_AWAITING_ACK_REQUEST
} SpiState;

volatile SpiState state = STATE_WAIT_FOR_LEN;

void spi_irq_handler();

void init_spi()
{
    // Initialize the SPI peripheral.
    spi_init(SPI_PORT, 500 * 1000);

    // Configure the SPI peripheral to operate in slave mode.
    // This is crucial for the Pico to act as a receiver.
    spi_set_slave(SPI_PORT, true);

    // Set up the GPIO pins for their SPI functions.
    // These functions map the physical pins to the SPI peripheral's signals.
    gpio_set_function(PIN_MISO, GPIO_FUNC_SPI); // MISO as SPI function
    gpio_set_function(PIN_CS,   GPIO_FUNC_SPI); // CS as SPI function
    gpio_set_function(PIN_SCK,  GPIO_FUNC_SPI); // SCK as SPI function
    gpio_set_function(PIN_MOSI, GPIO_FUNC_SPI); // MOSI as SPI function
    printf("SPI Slave configured.\n");

    // --- Interrupt Configuration ---
    // Enable the SPI interrupt (specifically for receive FIFO not empty)
    // The '1' enables the RX FIFO interrupt. The other '0's disable other sources.
    spi_get_hw(SPI_PORT)->imsc = (1 << SPI_SSPIMSC_RXIM_LSB);

    // Set the handler function for the SPI IRQ
    irq_set_exclusive_handler(SPI_IRQ, spi_irq_handler);
    
    // Enable the IRQ in the Nested Vector Interrupt Controller (NVIC)
    irq_set_enabled(SPI_IRQ, true);
    printf("SPI interrupt configured and enabled.\n\nReady to receive...\n");

    // Add binary information for picotool. This helps in identifying pin usage
    // when inspecting the compiled binary.
    // bi_decl(bi_4pins_with_func(PIN_MISO, PIN_CS, PIN_SCK, PIN_MOSI, (uint32_t)GPIO_FUNC_SPI));
}

// --- Interrupt Service Routine ---
// This function is called automatically whenever the SPI peripheral has data.
void spi_irq_handler()
{
    // As long as data is in the receive FIFO, process it.
    while (spi_is_readable(SPI_PORT))
    {
        uint8_t received_byte;
        spi_read_blocking(SPI_PORT, spi_return_byte, &received_byte, 1);

        debug_buffer[debug_buffer_index++] = received_byte;
        if (debug_buffer_index >= 1024)
        {
            // Reset the debug buffer index if it exceeds the size.
            debug_buffer_index = 0;
        }

        if (received_byte == SPI_SYNC_BYTE)
        {
            // If we receive a sync byte, we reset the sync bytes count.
            sync_bytes_received++;

            if (sync_bytes_received >= SPI_SYNC_BYTES_COUNT)
            {
                // We have received enough sync bytes, reset the count.
                sync_bytes_received = 0;
                length_received_count = 0; // Reset length received count for new message
                state = STATE_WAIT_FOR_LEN; // Transition to waiting for length state
            }

            // Skip further processing for this byte
            continue;
        }
        else
        {
            // If we receive a byte that is not a sync byte, reset the sync bytes count.
            sync_bytes_received = 0;
        }

        switch (state)
        {
            case STATE_WAIT_FOR_LEN:
                gpio_put(LED_PIN, 0);
                length_buffer[length_received_count++] = received_byte;
                if (length_received_count >= LENGTH_SIZE)
                {
                    // We have received the full length of the message.
                    // Convert the length from bytes to an integer.
                    message_length = 0;
                    for (int i = (LENGTH_SIZE - 1); i >= 0; i--)
                    {
                        message_length |= (length_buffer[i] << (8 * i));
                    }
                    
                    // Reset the length received count for the next message.
                    length_received_count = 0;

                    // Check if the received length is valid.
                    if (message_length > 0 && message_length < MAX_BUFFER_SIZE)
                    {
                        received_count = 0;
                        state = STATE_RECEIVING_DATA;
                    }
                    else
                    {
                        // Invalid length, reset state and wait for a new length.
                        state = STATE_WAIT_FOR_LEN;
                        printf("Invalid message length: %u\n", message_length);
                    }
                }
                break;

            case STATE_RECEIVING_DATA:
                gpio_put(LED_PIN, 1);
                if (received_count < MAX_BUFFER_SIZE)
                {
                    active_buffer[received_count++] = received_byte;
                }

                if (received_count >= message_length)
                {
                    // Message complete. Make it available for the main loop.
                    processing_buffer = active_buffer;
                    // Switch to the other buffer for the next reception.
                    active_buffer = (active_buffer == buffer_a) ? buffer_b : buffer_a;
                    
                    // Pre-load the ACK into the TX FIFO for the master to read.
                    //const uint8_t ack = ACK_SUCCESS;
                    // spi_write_blocking(SPI_PORT, &ack, 1);
                    spi_return_byte = ACK_SUCCESS; // Prepare ACK byte to be sent back
                    
                    state = STATE_AWAITING_ACK_REQUEST;
                }
                break;

            case STATE_AWAITING_ACK_REQUEST:
                // The master sent its dummy byte, our ACK has been sent.
                // Reset the state machine for the next transaction.
                state = STATE_WAIT_FOR_LEN;
                spi_return_byte = 0x00;
                
                gpio_put(LED_PIN, 0);
                break;
        }
    }
}

uint32_t spi_get_received_message(uint8_t* buffer, uint32_t max_length)
{
    if (processing_buffer != NULL)
    {
        if (max_length < message_length)
        {
            // If the provided buffer is smaller than the received message return the length
            // of the received message, but do not copy the data.
            // This will indicate that the buffer was too small.
            // The caller can handle this case as needed.
            return message_length;
        }

        gpio_put(LED_PIN, 1);

        // Print the received message safely.
        for (int i = 0; i < message_length; ++i)
        {
           buffer[i] = processing_buffer[i];
        }

        // Signal that we are done with the buffer.
        // This is the "handshake" back to the ISR, telling it the buffer is free.
        processing_buffer = NULL;

        gpio_put(LED_PIN, 0);

        return message_length; // Return the length of the received message
    }
    else
    {
        // No complete message available yet.
        return 0;
    }
}
